<!DOCTYPE html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC echo test</title>
</head>
<style>
html, body {
  height: 100%;
  position: relative;
}
#log { white-space: pre; }
#canvas {
	width: 100%;
	height: 100%;
	display: none;
	position: absolute;
	top: 0;
	left: 0;
}
#progress {
  border: 1px solid gray;
  height: 20px;
  padding: 1px;
  position: relative;
}
#progress .bar {
  box-sizing: border-box;
  background: blue;
  width: 0%;
  height: 100%;
}
body.fullscreen #configuration {
  display: none;
}
body.fullscreen #canvas {
  display: block;
}
body.fullscreen #save {
  position: absolute;
  top: 2px;
  left: 2px;
}
body.fullscreen #save {
  display: block;
}
</style>
<script src="webrtc-connection.js"></script>
<script src="https://www.chartjs.org/dist/2.7.2/Chart.bundle.js"></script>
<script src="https://www.chartjs.org/samples/latest/utils.js"></script>
<body>
<div id="configuration">
  <p>
    Ping test of establishing a connection to the server and sending messages and
    measuring the response time.
  </p>

  <span>Number of messages: </span><input id="message-count" value="30">
  <p>
    The number of messages to send in the test.
  </p>

  <span>Message interval (in milliseconds): </span><input id="message-interval" value="30">
  <p>
    The time between sending each message. In a game this would normally be
    whatever your game's network update loop interval was. Message receipt is not
    waited for.
  </p>

  <span>Message timeout (in milliseconds): </span><input id="message-timeout" value="1000">
  <p>
    The maximum time to wait for responses once all messages are sent.
  </p>

  <span>Message length (in bytes): </span><input id="message-length" value="1000">
  <p>
    The length of message to send. When targeting performance, this should be
    less than the fragmentation threshold and allow for some overhead from the
    protocol.
  </p>

  <span>Use custom server: </span><input id="server-name"><br>
  <button id="run-test">Run test</button>

  <p>
  Note about iOS: IOS requires calling getUserMedia before allowing WebRTC to
  establish a direct connection.addEventListener
  </p>
  <button id="get-user-media">Get User Media</button>
  <div id="progress"><div class="bar"></div></div>
  <div id="log"></div>
</div>
<canvas id="canvas"></canvas>
<a id="save">Save</a>
<script>

function $(id) {
  return document.getElementById(id);
}

function log(text) {
  // No logging.
  // document.getElementById('log').textContent += text + '\n';
}

function setProgress(p) {
  document.querySelector('#progress .bar').style.width = (p * 100) + '%';
}

function pingTest(connection, frequency, messages, message_length, timeout, test, num_tests) {
  return new Promise(function(resolve) {
    let results = {
      dropped: 0,
      unordered: 0,
      connection: 0,
      latency: [],
    };
    function testDone() {
      clearTimeout(timeoutTimer);
      clearInterval(interval);
      if (received < messages) {
        results.dropped = messages - received;
        for (let i = 0; i < results.dropped; i++) {
          // Push timeout for dropped results.
          results.latency.push(timeout);
        }
        log('Dropped ' + (messages - received) + ' messages.');
      }
      connection.removeEventListener('message', onmessage);
      connection.close();
      setProgress((test + 1) / num_tests);
      resolve(results);
    }
    let pingStartTimes = [];
    let received = 0;
    let lastResponse = -1;
    let timeoutTimer = undefined;

    let prefix = '';
    while (prefix.length < message_length)
      prefix += String.fromCharCode(65 + (Math.random() * 26));

    function onmessage(evt) {
      let receiveTime = performance.now();
      let index = parseInt(evt.data.substring(prefix.length));
      if (index != lastResponse + 1)
        results.unordered++;
      while (lastResponse < index) {
        ++lastResponse;
        let time = (receiveTime - pingStartTimes[lastResponse]);
        results.latency.push(time);
        log('Ping ' + lastResponse + ' received in ' + time + 'ms');
      }
      received++;
      setProgress((test + (lastResponse / messages)) / num_tests);
      if (received == messages) {
        testDone();
      }
    }

    connection.addEventListener('message', onmessage);
    let interval = setInterval(function() {
      let index = pingStartTimes.length;
      pingStartTimes.push(performance.now());
      connection.send(prefix + index);
      if (pingStartTimes.length == messages) {
        clearInterval(interval);
        timeoutTimer = setTimeout(testDone, timeout)
      }
    }, frequency);
  });
}

let test = 0;
let num_tests = 2;

async function testWebRTC(params) {
  log('Connecting WebRTC...');
  let start = performance.now();
  let url = location.origin.replace('http', 'ws') + location.pathname + 'echo';
  if ($('server-name').value)
    url = location.origin.replace('http', 'ws') + location.pathname + 'connect/' + $('server-name').value;
  let conn = await WebRTCConnection.establish(new WebSocket(url));
  let duration = performance.now() - start;
  log('WebRTC connection established in ' + duration + 'ms');
  let results = await pingTest(conn, params.interval, params.count, params.length, params.timeout, test, num_tests);
  results.connection = duration;
  return results;
}

function testWebSocket(params) {
  return new Promise(function (resolve, reject) {
    log('Connecting WebSocket...');
    let start = performance.now();
    let ws = new WebSocket(location.origin.replace('http', 'ws') + location.pathname + 'echo-websocket');
    ws.onopen = async function() {
      let duration = performance.now() - start;
      log('WebSocket connection established in ' + duration + 'ms');
      let results = await pingTest(ws, params.interval, params.count, params.length, params.timeout, test, num_tests);
      results.connection = duration;
      resolve(results);
    };
  });
}

const color = Chart.helpers.color;
async function runTests() {
  // Clear log first.
  $('log').textContent = '';
  let params = {
    count: parseInt($('message-count').value),
    interval: parseInt($('message-interval').value),
    timeout: parseInt($('message-timeout').value),
    length: parseInt($('message-length').value),
  }
  let results = {WebSocket: undefined, WebRTC: undefined};
  num_tests = 2;
  results.WebSocket = await testWebSocket(params);
  ++test;
  results.WebRTC = await testWebRTC(params);
  ++test;

  window.results = results;
  let saveLink = $('save');
  saveLink.download = 'latency.json';
  saveLink.href = 'data:text/json,' + JSON.stringify(results);

  document.body.classList.add('fullscreen');
  var ctx = document.getElementById('canvas').getContext('2d');
    window.myScatter = new Chart(ctx, {
    type: 'line',
    data: generateData(results),
    options: {
      maintainAspectRatio: false,
      title: {
      	display: true,
      	text: 'Latency Test'
      },
      scales: {
      	xAxes: [{
      	  type: 'linear',
      	  position: 'bottom',
      	  ticks: {
      	    userCallback: function(tick) {
      		    return (tick * 100).toString() + '%';
      	    },
      	  },
      	  scaleLabel: {
      	    labelString: 'Percentile',
      	    display: true,
      	  }
      	}],
      	yAxes: [{
      	  type: 'linear',
      	  ticks: {
            beginAtZero: true,
          },
      	  scaleLabel: {
      	    labelString: 'Latency (ms)',
      	    display: true
      	  }
      	}]
      }
    }
  });
}

function generateData(results) {
  return {datasets: [
    {
      borderColor: window.chartColors.red,
      backgroundColor: color(window.chartColors.red).alpha(0.5).rgbString(),
      label: 'WebSocket',
      data: generateDataSet(results.WebSocket),
    }, {
      borderColor: window.chartColors.blue,
      backgroundColor: color(window.chartColors.blue).alpha(0.5).rgbString(),
      label: 'WebRTC DataChannel',
      data: generateDataSet(results.WebRTC),
    }]};
}

function generateDataSet(results) {
  let scatter = {};
  let chartData = [];
  let values = results.latency.concat().sort((a, b) => {return a - b;});
  for (let i = 0; i < values.length; i++) {
    chartData.push({
      x: i / (values.length - 1),
      y: values[i],
    });
  }
  return chartData;
}

document.addEventListener('DOMContentLoaded', function() {
  $('run-test').addEventListener('click', runTests);
  $('get-user-media').addEventListener('click', function() {
    var constraints = { audio: true, video: false };

    window.navigator.mediaDevices.getUserMedia(constraints)
    .then(function(mediaStream) {
      $('get-user-media').textContent = 'Got user media';
    });
  });
});
</script>
</body>